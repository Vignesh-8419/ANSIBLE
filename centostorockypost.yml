---
- name: Full RPMDB + Kernel Cleanup & UEFI rescue fix for Rocky Linux 8
  hosts: all
  become: true
  gather_facts: yes

  pre_tasks:
    - name: Ensure system is Rocky Linux 8
      assert:
        that:
          - ansible_distribution == "Rocky"
          - ansible_distribution_major_version == "8"
        fail_msg: "❌ This playbook can run ONLY on Rocky Linux 8!"
        success_msg: "✔ Rocky Linux 8 detected. Continuing..."

  vars:
    efi_mount: /boot/efi
    efi_vendor_dir: "{{ efi_mount }}/EFI/rocky"
    backup_dir: /root/efi_backup_{{ ansible_date_time.epoch }}

  tasks:
    - name: Ensure backup directory exists
      file:
        path: /etc/yum.repos.d/backup
        state: directory
        mode: '0755'

    - name: Move all repo files except backup directory
      shell: |
        shopt -s extglob
        mv /etc/yum.repos.d/!(backup) /etc/yum.repos.d/backup/ || true
      args:
        executable: /bin/bash
      ignore_errors: yes

    - name: Create Rocky Linux 8 repo
      copy:
        content: |
          [rocky8-baseos]
          name=Rocky Linux 8 - BaseOS
          baseurl=http://http-server-01/repo/rocky8/BaseOS/
          gpgcheck=0
          enabled=1

          [rocky8-appstream]
          name=Rocky Linux 8 - AppStream
          baseurl=http://http-server-01/repo/rocky8/AppStream/
          gpgcheck=0
          enabled=1
        dest: /etc/yum.repos.d/base.repo

    - name: Backup current RPM database
      command:
        cmd: mv /var/lib/rpm /var/lib/rpm.bak-{{ ansible_date_time.epoch }}
      args:
        creates: "/var/lib/rpm.bak-{{ ansible_date_time.epoch }}"

    - name: Create new empty RPM db directory
      file:
        path: /var/lib/rpm
        state: directory
        mode: '0755'

    - name: Initialize new RPM database
      command: rpm --initdb

    - name: Restore Packages file from backup (best-effort)
      command: cp -av /var/lib/rpm.bak-{{ ansible_date_time.epoch }}/Packages /var/lib/rpm/
      ignore_errors: yes

    - name: Force remove stale __db* files (best-effort)
      shell: rm -f /var/lib/rpm/__db.* || true
      args:
        executable: /bin/bash
      ignore_errors: yes

    - name: Rebuild RPM database
      command: rpm --rebuilddb

    - name: Clean DNF cache
      command: dnf clean all

    - name: Verify rpmdb works
      command: dnf list installed
      register: rpmdb_test
      ignore_errors: yes

    - debug:
        msg: "RPM DB status: {{ rpmdb_test.stdout | default('Failed to query rpmdb') }}"

    # -----------------------------
    # Kernel / el7 leftovers cleanup
    # -----------------------------
    - name: List old el7 kernel directories
      shell: ls -d /lib/modules/*.el7* || true
      register: old_kernels
      changed_when: false

    - name: Remove weak-modules for old el7 kernels
      shell: |
        for k in $(ls -d /lib/modules/*.el7* 2>/dev/null | xargs -n1 basename); do
          /usr/sbin/weak-modules --remove-kernel $k || true
        done
      args:
        executable: /bin/bash
      when: old_kernels.stdout != ""

    - name: Remove old kernels via kernel-install
      shell: |
        for k in $(ls -d /lib/modules/*.el7* 2>/dev/null | xargs -n1 basename); do
          /bin/kernel-install remove $k /lib/modules/$k/vmlinuz || true
        done
      args:
        executable: /bin/bash
      when: old_kernels.stdout != ""

    - name: Find leftover el7 RPMs
      shell: |
        rpm -qa | grep -E '\.el[67]' | grep -vE '^(gpg-pubkey|libmoduled|katello-ca-consumer)' | sort || true
      register: el7_rpms
      changed_when: false

    - name: Save el7 package list
      copy:
        dest: /tmp/rhel7.txt
        content: "{{ el7_rpms.stdout }}"

    - name: Remove leftover el7 RPMs (best-effort)
      shell: |
        if [ -s /tmp/rhel7.txt ]; then
          for i in $(cat /tmp/rhel7.txt); do
            echo "Removing $i"
            rpm -e $i --nodeps || true
          done
        fi
      args:
        executable: /bin/bash

    - name: Cleanup leapp packages
      shell: dnf remove -y leapp* || true

    - name: Remove leapp logs and old kernel dirs
      file:
        path: "{{ item }}"
        state: absent
      loop:
        - /lib/modules/*el7*
        - /var/log/leapp/
        - /root/tmp_leapp_py3
        - /var/lib/leapp/
        - /boot/vmlinuz-*rescue*
        - /boot/initramfs-*rescue*

    - name: Reinstall current kernel-core (ensure correct kernel artifacts present)
      shell: dnf reinstall -y kernel-core || true

    - name: Verify old kernels are not in grub (report only)
      shell: grubby --info=ALL | grep -E '\.el7' || echo "Old Kernels are not present in the bootloader."
      register: grub_check
      changed_when: false

    - debug:
        var: grub_check.stdout_lines

    # -----------------------------
    # UEFI-specific rescue fixes
    # -----------------------------
    - name: Ensure efibootmgr and grub2-efi packages installed (UEFI hosts only)
      yum:
        name:
          - efibootmgr
          - grub2-efi-x64  # best-effort package name; on some systems it may be grub2-efi
          - dracut
        state: present
      when: ansible_facts.get('efi') is defined

    - name: Ensure EFI mount point exists and is mounted (if efi detected)
      block:
        - name: Ensure efi mount directory exists
          file:
            path: "{{ efi_mount }}"
            state: directory

        - name: Fail if /boot/efi is not a mount (EFI host)
          stat:
            path: "{{ efi_mount }}"
          register: efi_stat

        - name: Mount EFI if not mounted (attempt)
          mount:
            path: "{{ efi_mount }}"
            src: UUID={{ ansible_facts.get('efivars_uuid','') }}
            fstype: vfat
            state: mounted
          when: efi_stat.stat.exists and not efi_stat.stat.ismount
          ignore_errors: yes
      when: ansible_facts.get('efi') is defined

    - name: Create local backup of existing EFI Rocky files (if any)
      file:
        path: "{{ backup_dir }}"
        state: directory
        mode: '0700'
      when: ansible_facts.get('efi') is defined

    - name: Backup Rocky EFI dir if exists
      shell: |
        if [ -d "{{ efi_vendor_dir }}" ]; then
          cp -a "{{ efi_vendor_dir }}" "{{ backup_dir }}/"
        fi
      args:
        executable: /bin/bash
      when: ansible_facts.get('efi') is defined

    - name: Regenerate rescue initramfs for current kernel (force)
      shell: dracut -f /boot/initramfs-{{ ansible_kernel }}-rescue.img {{ ansible_kernel }}
      register: rebuild_rescue
      changed_when: "'created' in rebuild_rescue.stdout or rebuild_rescue.rc == 0"
      ignore_errors: yes

    - name: Ensure vmlinuz rescue symlink exists (create safe aliases used by some rescue entries)
      shell: |
        # Some rescue grub entries reference vmlinuz-0-rescue-<id> or similar.
        # Create safe names pointing to current kernel vmlinuz and initramfs.
        KERNEL="{{ ansible_kernel }}"
        VF="/boot"
        # create a stable '0-rescue' style symlink if not exists
        if [ -f "${VF}/vmlinuz-${KERNEL}" ] && [ ! -e "${VF}/vmlinuz-0-rescue" ]; then
          ln -s "vmlinuz-${KERNEL}" "${VF}/vmlinuz-0-rescue" || true
        fi
        if [ -f "${VF}/initramfs-${KERNEL}.img" ] && [ ! -e "${VF}/initramfs-0-rescue.img" ]; then
          ln -s "initramfs-${KERNEL}.img" "${VF}/initramfs-0-rescue.img" || true
        fi
      args:
        executable: /bin/bash
      when: ansible_facts.get('efi') is defined

    - name: Regenerate grub.cfg (BIOS/EFI)
      shell: |
        grub2-mkconfig -o /boot/grub2/grub.cfg || true
        if [ -d "{{ efi_vendor_dir }}" ]; then
          grub2-mkconfig -o "{{ efi_vendor_dir }}/grub.cfg" || true
        fi
      args:
        executable: /bin/bash

    - name: Install grub2 EFI bootloader to /boot/efi (explicit target)
      shell: >
        grub2-install --target=x86_64-efi --efi-directory={{ efi_mount }}
        --bootloader-id="rocky" || true
      args:
        executable: /bin/bash
      when: ansible_facts.get('efi') is defined

    - name: Remove EFI files that explicitly contain 'rescue' in name (if you want them gone)
      shell: |
        set -x
        if [ -d "{{ efi_vendor_dir }}" ]; then
          find "{{ efi_vendor_dir }}" -type f -iname "*rescue*" -print -exec rm -f {} \; || true
        fi
      args:
        executable: /bin/bash
      when: ansible_facts.get('efi') is defined

    - name: Clean duplicate or stale EFI boot entries (remove entries with labels containing CentOS or duplicate 'Rocky Linux Rescue')
      shell: |
        efibootmgr -v | awk -F'\\*' '/Boot[0-9A-Fa-f]+/ { print $0 }' > /tmp/efibootmgr_raw.txt || true
        # Delete entries by number if their label contains "CentOS" or "Rescue" duplicate patterns
        efibootmgr -v | while IFS= read -r line; do
          # sample line: Boot0004* Rocky Linux Rescue  HD(1,GPT,...)...
          if echo "$line" | grep -E "CentOS|rescue|Rescue" -qi; then
            num=$(echo "$line" | awk '{print $1}' | sed 's/Boot//; s/[*]*//;')
            if [ -n "$num" ]; then
              printf "Deleting EFI entry Boot%s (matched CentOS/Rescue)\n" "$num"
              efibootmgr -b "$num" -B || true
            fi
          fi
        done
      args:
        executable: /bin/bash
      when: ansible_facts.get('efi') is defined

    - name: Ensure a single clean EFI boot entry for Rocky exists (create if missing)
      shell: |
        # Create a Rocky entry if none exists pointing at \EFI\rocky\grubx64.efi
        TARGET="\\EFI\\rocky\\grubx64.efi"
        LABEL="Rocky Linux"
        found=$(efibootmgr | awk -v lab="$LABEL" 'tolower($0) ~ tolower(lab) {print $1}')
        if [ -z "$found" ]; then
          efibootmgr --create --disk /dev/sda --part 1 --label "$LABEL" --loader "$TARGET" || true
          echo "Created EFI entry for $LABEL -> $TARGET"
        else
          echo "EFI entry for $LABEL already present: $found"
        fi
      args:
        executable: /bin/bash
      when: ansible_facts.get('efi') is defined

    - name: Set Rocky entry as first boot option (if present)
      shell: |
        # Find Boot#### number for label "Rocky Linux" (case-insensitive)
        bootnum=$(efibootmgr | awk 'BEGIN{IGNORECASE=1} /Rocky Linux/ {print $1; exit}' | sed 's/Boot//')
        if [ -n "$bootnum" ]; then
          # get current order, prepend this bootnum and dedupe
          order=$(efibootmgr | awk -F': ' '/BootOrder/ {print $2}')
          # build new order with bootnum first
          new="${bootnum}"
          for b in $(echo "$order" | tr -d ',' | sed 's/./& /g'); do :; done
          # attempt to set new order by calling efibootmgr with new order
          efibootmgr -o $bootnum,$(echo "$order" | sed "s/$bootnum,//" | sed 's/,/ /g' | tr -s ' ' ',') || true
          echo "Attempted to make Boot${bootnum} first in BootOrder"
        fi
      args:
        executable: /bin/bash
      when: ansible_facts.get('efi') is defined

    - name: Final verification - list EFI boot entries
      command: efibootmgr -v
      register: efiboot_list
      changed_when: false
      when: ansible_facts.get('efi') is defined

    - debug:
        var: efiboot_list.stdout_lines
      when: ansible_facts.get('efi') is defined

    - name: Rebuild rescue initramfs check (report)
      shell: lsinitrd /boot/initramfs-{{ ansible_kernel }}-rescue.img | grep -q "modules/" && echo "OK" || echo "FAIL"
      register: rescue_modules_check
      changed_when: false

    - debug:
        var: rescue_modules_check.stdout

    # Optional: reboot if you want to apply boot order change immediately
    - name: Optional: reboot host after UEFI changes (comment/uncomment as needed)
      ansible.builtin.reboot:
        msg: "Rebooting after UEFI rescue fix (optional)"
        reboot_timeout: 600
      when: false
