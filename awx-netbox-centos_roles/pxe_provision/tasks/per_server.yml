---
# STEP 1: PREPARE NETWORK INFRASTRUCTURE
- name: Add DHCP reservation and restart service
  shell: |
    sshpass -p "{{ ansible_password }}" ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null root@192.168.253.160 <<EOF
    sed -i '/# BEGIN ANSIBLE {{ server.hostname }}/,/# END ANSIBLE {{ server.hostname }}/d' /etc/dhcp/dhcpd.conf
    cat >> /etc/dhcp/dhcpd.conf <<DHCP_EOF
    # BEGIN ANSIBLE {{ server.hostname }}
    host {{ server.hostname }} {
      hardware ethernet {{ server.mac }};
      fixed-address {{ server.ip }};
      option host-name "{{ server.hostname }}";
      filename "grub2/grubx64.efi";
    }
    # END ANSIBLE {{ server.hostname }}
    DHCP_EOF
    systemctl restart dhcpd
    EOF
  delegate_to: localhost

- name: Generate per-host GRUB config
  shell: |
    sshpass -p "{{ ansible_password }}" ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null root@192.168.253.160 "cat > /var/lib/tftpboot/grub2/grub.cfg-01-{{ server.mac | regex_replace(':','-') | lower }}" <<EOF
    {{ lookup('template', 'grub-centos7.j2') }}
    EOF
  delegate_to: localhost

# STEP 2: ESXi DIRECT VM MANAGEMENT
- name: Configure and Power On VM on ESXi host
  shell: 
    cmd: |
      sshpass -p '{{ nb_ctx.exsi_password }}' ssh -o StrictHostKeyChecking=no {{ nb_ctx.exsi_username }}@{{ nb_ctx.exsi_hostname }} <<'EOF'
        # 1. Find VMID
        VMNAME="{{ server.hostname.split('.')[0] }}"
        VMID=$(vim-cmd vmsvc/getallvms | grep -w "$VMNAME" | awk '{print $1}')
        
        if [ -z "$VMID" ]; then echo "VM $VMNAME not found"; exit 1; fi
        
        # 2. Get Absolute VMX Path
        # vim-cmd returns 'datastore path', we convert it to /vmfs/volumes/datastore/path
        VMX_INFO=$(vim-cmd vmsvc/get.config $VMID | grep -i 'vmxPath' | awk -F'"' '{print $2}')
        DS_NAME=$(echo "$VMX_INFO" | awk -F' ' '{print $1}' | tr -d '[]')
        REL_PATH=$(echo "$VMX_INFO" | awk -F' ' '{print $2}')
        FULL_VMX_PATH="/vmfs/volumes/$DS_NAME/$REL_PATH"
        
        if [ ! -f "$FULL_VMX_PATH" ]; then echo "File $FULL_VMX_PATH not found"; exit 1; fi

        # 3. Stop VM
        vim-cmd vmsvc/power.off $VMID >/dev/null 2>&1 || true
        
        # 4. Modify VMX for UEFI + PXE Boot
        sed -i '/firmware/d' "$FULL_VMX_PATH"
        sed -i '/bios.bootOrder/d' "$FULL_VMX_PATH"
        echo 'firmware = "efi"' >> "$FULL_VMX_PATH"
        echo 'bios.bootOrder = "ethernet,disk"' >> "$FULL_VMX_PATH"
        
        # 5. Start VM
        vim-cmd vmsvc/power.on $VMID
        
        # 6. Wait for PXE to start (25s), then flip order back to Disk
        # We do this so the NEXT reboot uses the hard drive
        sleep 25
        sed -i 's/ethernet,disk/disk,ethernet/' "$FULL_VMX_PATH"
      EOF
  delegate_to: localhost

# STEP 3: MONITOR INSTALLATION

- name: Wait for VM to respond to SSH
  wait_for:
    host: "{{ server.ip }}"
    port: 22
    state: started
    delay: 60
    timeout: 1800
  delegate_to: localhost

- name: Verify Kernel Version
  shell: |
    ssh-keygen -R {{ server.ip }} || true
    ssh-keyscan -H {{ server.ip }} >> /tmp/known_hosts
    ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/tmp/known_hosts root@{{ server.ip }} 'uname -r'
  register: kernel_version
  delegate_to: localhost
