---
# STEP 1: PREPARE THE NETWORK INFRASTRUCTURE (DHCP & TFTP)
- name: Add DHCP reservation and restart service
  shell: |
    sshpass -p "{{ ansible_password }}" ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null root@192.168.253.160 <<EOF
    sed -i '/# BEGIN ANSIBLE {{ server.hostname }}/,/# END ANSIBLE {{ server.hostname }}/d' /etc/dhcp/dhcpd.conf
    cat >> /etc/dhcp/dhcpd.conf <<DHCP_EOF
    # BEGIN ANSIBLE {{ server.hostname }}
    host {{ server.hostname }} {
      hardware ethernet {{ server.mac }};
      fixed-address {{ server.ip }};
      option host-name "{{ server.hostname }}";
      filename "grub2/grubx64.efi";
    }
    # END ANSIBLE {{ server.hostname }}
    DHCP_EOF
    systemctl restart dhcpd
    EOF
  delegate_to: localhost

- name: Generate per-host GRUB config via SSH pipe
  shell: |
    sshpass -p "{{ ansible_password }}" ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null root@192.168.253.160 "cat > /var/lib/tftpboot/grub2/grub.cfg-01-{{ server.mac | regex_replace(':','-') | lower }}" <<EOF
    {{ lookup('template', 'grub-centos7.j2') }}
    EOF
  delegate_to: localhost

# STEP 2: CONFIGURE VM HARDWARE AND BOOT ORDER
- name: Configure and Power On existing VM
  shell: |
    # 1. Get Authentication Token
    SESSION_ID=$(curl -k -s -X POST \
      -u "{{ nb_ctx.vcenter_username }}:{{ nb_ctx.vcenter_password }}" \
      https://{{ nb_ctx.vcenter_hostname }}/api/session | tr -d '"')

    # 2. Get the VM ID by name
    VM_ID=$(curl -k -s -H "vmware-api-session-id: $SESSION_ID" \
      "https://{{ nb_ctx.vcenter_hostname }}/api/vcenter/vm?names={{ server.hostname }}" | grep -o 'vm-[0-9]*' | head -1)

    # 3. Set Firmware to UEFI (Required for grubx64.efi)
    curl -k -s -X PATCH "https://{{ nb_ctx.vcenter_hostname }}/api/vcenter/vm/$VM_ID" \
      -H "vmware-api-session-id: $SESSION_ID" \
      -H "Content-Type: application/json" \
      -d '{ "boot": { "type": "EFI" } }'

    # 4. Set Boot Order to ETHERNET first
    curl -k -s -X PATCH "https://{{ nb_ctx.vcenter_hostname }}/api/vcenter/vm/$VM_ID" \
      -H "vmware-api-session-id: $SESSION_ID" \
      -H "Content-Type: application/json" \
      -d '{ "boot": { "network_protocol": "IPV4" } }'

    # 5. Power On the VM
    curl -k -s -X POST "https://{{ nb_ctx.vcenter_hostname }}/api/vcenter/vm/$VM_ID/power?action=start" \
      -H "vmware-api-session-id: $SESSION_ID"

    # 6. Wait 15 seconds to ensure PXE process has started, then revert boot order to DISK
    # This ensures that when the OS install reboots the VM, it boots from the HD, not PXE again.
    sleep 15
    curl -k -s -X PATCH "https://{{ nb_ctx.vcenter_hostname }}/api/vcenter/vm/$VM_ID" \
      -H "vmware-api-session-id: $SESSION_ID" \
      -H "Content-Type: application/json" \
      -d '{ "boot": { "type": "EFI" }, "boot_devices": [ { "type": "DISK" }, { "type": "ETHERNET" } ] }'
  delegate_to: localhost

# STEP 3: MONITOR FOR COMPLETION
- name: Wait for OS installation to complete (Ping check)
  wait_for:
    host: "{{ server.ip }}"
    port: 22
    state: started
    delay: 60      # Wait 1 min before first check
    timeout: 1200  # Give it up to 20 mins for full CentOS install
  delegate_to: localhost

- name: Final status
  debug:
    msg: "Server {{ server.hostname }} is now online and reachable at {{ server.ip }}"
